## Average Pool
### Input Dimension - 64x32x32
### Output Dimension - 64x32x32
Average pool can be done efficiently using the accelerator. Synthetic weight of below kernel can be generated by putting all the weights to 1 and filter masking the bottom and right part of the kernel. Additionally, a right shift of 2 is used in the NORMQUANT phase. This is managed by enabling AVG_POOL flag in the golden model while generating stimuli.
```
1 1 0
1 1 0
0 0 0
```
Depthwise mode requires 34x34 input data. Thus, by default the golden model will use 34x34 input patch. However, to use 32x32 patch we will need to export the 32x32 patch using the following changes to the infeat_export.c file. 
```
   file_ << "uint8_t ne16_infeat[] = {" << std::endl;
    for(auto i=0; i<this->h_in*this->stride-2*this->stride; i++) {
      for(auto j=0; j<this->w_in*this->stride-2*this->stride; j++) {

```
The stimuli is generated using
```
make stimuli AVG_POOL=1 NEGATIVE_WEIGHT=0 K_IN=64 K_OUT=64 H_OUT=32 W_OUT=32 FS=3 QW=2 NO_NORM_QUANT=0 NORM_BITS=8 QUANT_BITS=8 NORM_SHIFT=1 NORM_BIAS=0 USE_ROUNDING=0 USE_RELU=0 PADDING_TOP=0 PADDING_RIGHT=6 PADDING_BOTTOM=6 PADDING_LEFT=0 PADDING_VALUE=0 STREAMIN=0 FILTER_MASK_TOP=0 FILTER_MASK_RIGHT=1 FILTER_MASK_BOTTOM=1 FILTER_MASK_LEFT=0 DEPTHWISE=1 MODE16=0 MODE_LINEAR=0 WEIGHT_DEMUX=1 ACTIVATION_PREFETCH=1 SIGNED_ACTIVATION=1 STRIDE=1 FEATURE_FROM_FILE=0
```
Additionally, the infeat.d1_stride needs to be modified from 64*34 to 64*32. Simulation is run using 
```
make build-sw sim gui=1 AVG_POOL=1 NEGATIVE_WEIGHT=0 K_IN=64 K_OUT=64 H_OUT=32 W_OUT=32 FS=3 QW=2 NO_NORM_QUANT=0 NORM_BITS=8 QUANT_BITS=8 NORM_SHIFT=1 NORM_BIAS=0 USE_ROUNDING=0 USE_RELU=0 PADDING_TOP=0 PADDING_RIGHT=6 PADDING_BOTTOM=6 PADDING_LEFT=0 PADDING_VALUE=0 STREAMIN=0 FILTER_MASK_TOP=0 FILTER_MASK_RIGHT=1 FILTER_MASK_BOTTOM=1 FILTER_MASK_LEFT=0 DEPTHWISE=1 MODE16=0 MODE_LINEAR=0 WEIGHT_DEMUX=1 ACTIVATION_PREFETCH=1 SIGNED_ACTIVATION=1 STRIDE=1 FEATURE_FROM_FILE=0
```
## Pointwise Convolution
### Input Dimension 64x32x32
### Output Dimension 32x16x16
Here a stride of 2 is used to reduce the size of the feature map. 
The golden model is used as it is. There is a support for stride=2 is added. The input is same as the input used for the averagepool. There is an additional support in the golden model to use the feature from a header file "feature.hpp". The content of ne16_infeat.h generated in the averagepool is copied to feature.hpp file. Then the golden model is build. The stimuli generation and simulation is performed using 
```
make stimuli build-sw sim gui=1 AVG_POOL=0 NEGATIVE_WEIGHT=0 K_IN=64 K_OUT=32 H_OUT=16 W_OUT=16 FS=1 QW=8 NO_NORM_QUANT=0 NORM_BITS=8 QUANT_BITS=8 NORM_SHIFT=1 NORM_BIAS=1 USE_ROUNDING=0 USE_RELU=0 PADDING_TOP=0 PADDING_RIGHT=0 PADDING_BOTTOM=0 PADDING_LEFT=0 PADDING_VALUE=0 STREAMIN=0 FILTER_MASK_TOP=0 FILTER_MASK_RIGHT=0 FILTER_MASK_BOTTOM=0 FILTER_MASK_LEFT=0 DEPTHWISE=0 MODE16=0 MODE_LINEAR=0 WEIGHT_DEMUX=1 ACTIVATION_PREFETCH=1 SIGNED_ACTIVATION=1 STRIDE=2 FEATURE_FROM_FILE=1
```
## Pointwise Convolution
### Input Dimension 64x32x32
### Output Dimension 64x16x16
This layer takes the output of the averagepool as the input. Thus, teh content of the ne16_outfeat.h is copied to the feature.hpp of the golden model. The output of the average pool is 32x32 patch because in the current model of neureka selective streamout with stride=2 is not supported. Thus, this layer requires stride=2 as the input. The golden model is build after these changes. The simulation is run using 
```
make stimuli build-sw sim gui=1 AVG_POOL=0 NEGATIVE_WEIGHT=0 K_IN=64 K_OUT=64 H_OUT=16 W_OUT=16 FS=1 QW=8 NO_NORM_QUANT=1 NORM_BITS=32 QUANT_BITS=32 NORM_SHIFT=0 NORM_BIAS=0 USE_ROUNDING=0 USE_RELU=0 PADDING_TOP=0 PADDING_RIGHT=0 PADDING_BOTTOM=0 PADDING_LEFT=0 PADDING_VALUE=0 STREAMIN=0 FILTER_MASK_TOP=0 FILTER_MASK_RIGHT=0 FILTER_MASK_BOTTOM=0 FILTER_MASK_LEFT=0 DEPTHWISE=0 MODE16=0 MODE_LINEAR=0 WEIGHT_DEMUX=1 ACTIVATION_PREFETCH=1 SIGNED_ACTIVATION=1 STRIDE=2 FEATURE_FROM_FILE=1
```
## 3x3 Convolution
### Input Dimension 32x16x16
### Output Dimension 32x16x16
This layer takes the input as the output of the pointwise layer. Thus the ne16_outfeat.h generated for the pointwise layer is copied to the feature.hpp. Again it also needs to be arranged the similar to the depthwise mode, as the golde model requires/generates 18x18 patch for 3x3 convolution. The processing requires a padding of 0 in all the ends(top, bottom, left, right). Thus, from the golden model generate.cpp the following changes are made as we don't care about the inputs in the edge as they anyways be padded to 0.
```
if(this->feature_from_file)
  {
    std::cout<<"Reading from file"<<std::endl;
    for(int i=1; i<this->h_in*this->stride-1; i++){
      for(int j=1; j<this->w_in*this->stride-1; j++){
        for(int k=0; k<this->k_in; k++){
          int address = (i-1)*(this->w_in-2)*this->k_in*this->stride + (j-1)*this->k_in + k;
          if(this->signed_activation){
            int sign_bit = (ne16_infeat[address]&0x80)>>7;
            int shift_sign_bit = (sign_bit *(0xFFFFFFFF)) & 0xFFFFFF00;
            xt::view(this->x,xt::range(i,i+1),xt::range(j,j+1), xt::range(k,k+1)) = signed(shift_sign_bit + ne16_infeat[address]);
          } else {
            xt::view(this->x,xt::range(i,i+1),xt::range(j,j+1), xt::range(k,k+1)) = ne16_infeat[address];
          }
        }
      }
    }
  }
```
Additionally, while exporting the feature the input should be truncated to 16x16 instead of 18x18 as used by the golden model. Thus in the export.cpp the following changes are made
```
for(auto i=1; i<this->h_in*this->stride-1; i++) {
    for(auto j=1; j<this->w_in*this->stride-1; j++) {
      for(auto k=0; k<this->k_in; k++) {
          file_ << "  0x" << std::internal << std::setfill('0') << std::setw(2) <<std::hex <<  static_cast<int>((this->x(i,j,k)&0x000000FF)) << std::dec;
        if(i==this->h_in*this->stride-2 && j==this->w_in*this->stride-2 && k==this->k_in-1)
          file_ << std::endl << "};" << std::endl << std::endl;
        else
          file_ << "," << std::endl;
      }
    }
  }
```
The stimuli is generated using 
```
make stimuli AVG_POOL=0 NEGATIVE_WEIGHT=0 K_IN=32 K_OUT=32 H_OUT=16 W_OUT=16 FS=3 QW=8 NO_NORM_QUANT=0 NORM_BITS=8 QUANT_BITS=8 NORM_SHIFT=1 NORM_BIAS=1 USE_ROUNDING=0 USE_RELU=0 PADDING_TOP=1 PADDING_RIGHT=3 PADDING_BOTTOM=3 PADDING_LEFT=1 PADDING_VALUE=0 STREAMIN=0 FILTER_MASK_TOP=0 FILTER_MASK_RIGHT=0 FILTER_MASK_BOTTOM=0 FILTER_MASK_LEFT=0 DEPTHWISE=0 MODE16=0 MODE_LINEAR=0 WEIGHT_DEMUX=1 ACTIVATION_PREFETCH=1 SIGNED_ACTIVATION=1 STRIDE=1 FEATURE_FROM_FILE=1
```
The accelerator should start fetching the data from the actual infeature location (x-(32(input_channel)*17(input_win_size+1))). This emulates the behavior of padding in the top and left. Thus, x should be replaced with x-32*17 in the tb_ne16.c file in the sw folder. Additionally,the input stride is modified in the ne16_cfg.h to 32*16 instead of 32*18. Finally, the simulation is run using 
```
make build-sw sim gui=1 AVG_POOL=0 NEGATIVE_WEIGHT=0 K_IN=32 K_OUT=32 H_OUT=16 W_OUT=16 FS=3 QW=8 NO_NORM_QUANT=0 NORM_BITS=8 QUANT_BITS=8 NORM_SHIFT=1 NORM_BIAS=1 USE_ROUNDING=0 USE_RELU=0 PADDING_TOP=1 PADDING_RIGHT=3 PADDING_BOTTOM=3 PADDING_LEFT=1 PADDING_VALUE=0 STREAMIN=0 FILTER_MASK_TOP=0 FILTER_MASK_RIGHT=0 FILTER_MASK_BOTTOM=0 FILTER_MASK_LEFT=0 DEPTHWISE=0 MODE16=0 MODE_LINEAR=0 WEIGHT_DEMUX=1 ACTIVATION_PREFETCH=1 SIGNED_ACTIVATION=1 STRIDE=1 FEATURE_FROM_FILE=1
```
